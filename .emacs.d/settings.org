* Display
  Makes emacs look good by theme and gets rid of toolbar stuff
** Themes
   Choose Theme
   #+BEGIN_SRC emacs-lisp
     (use-package apropospriate-theme)
     (use-package nord-theme);
     ;; :config (load-theme 'nord nil))
     (load-theme 'apropospriate-dark t)
   #+END_SRC
** Some Defaults
   Gets rid of default options for display
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC
** Lines
   Makes VI relative line numbering
   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode)
     (setq-default display-line-numbers-type 'relative
		   display-line-numbers-current-absolute t
		   display-line-numbers-width 4
		   display-line-numbers-widen t)
   #+END_SRC
* Pre Config
  Preconfiguration. For stuff before actual config like variables
** General
   #+BEGIN_SRC emacs-lisp
     ;; @TODO(automatically get use-package

     (use-package quelpa
       :init '(setq quelpa-upgrade-p t
		    quelpa-stable-p t))
     (use-package quelpa-use-package)
     (use-package general
       :config (general-evil-setup t))
     (defvar HOME (getenv "HOME"))
     (defvar WM nil)
     (load-file (concat HOME "/.emacs.d/private.el"))
   #+END_SRC
** Functions
   Useful function
   #+BEGIN_SRC emacs-lisp
     (defun org-get-keyword (KEYWORD)
       "get the value from a line like this
     ,#+KEYWORD: value
     in a file."
       (interactive)
       (let ((case-fold-search t)
	     (re (format "^#\\+%s:[ \t]+\\([^\t\n]+\\)" KEYWORD)))
	 (if (not (save-excursion
		    (or (re-search-forward re nil t)
			(re-search-backward re nil t))))
	     (error (format "No line containing #+%s: value found" KEYWORD)))
	 (match-string 1)))

     (defun eshell/clear ()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
	 (erase-buffer)
	 (eshell-send-input)))
     (defun kill-other-buffers ()
       "Kill all other buffers."
       (interactive)
       (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

     (defun rename-file-and-buffer (new-name)
       "Renames both current buffer and file it's visiting to NEW-NAME."
       (interactive "New name: ")
       (let ((name (buffer-name))
	     (filename (buffer-file-name)))
	 (if (not filename)
	     (message "Buffer '%s' is not visiting a file!" name)
	   (if (get-buffer new-name)
	       (message "A buffer named '%s' already exists!" new-name)
	     (progn
	       (rename-file filename new-name 1)
	       (rename-buffer new-name)
	       (set-visited-file-name new-name)
	       (set-buffer-modified-p nil))))))

     (defun delete-file-and-buffer ()
       "Kill the current buffer and deletes the file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
	 (when filename
	   (if (vc-backend filename)
	       (vc-delete-file filename)
	     (progn
	       (delete-file filename)
	       (message "Deleted file %s" filename)
	       (kill-buffer))))))

     (defun sudo-edit (&optional arg)
       (interactive "P")
       (if (or arg (not buffer-file-name))
	   (find-file (concat "/sudo:root@localhost:"
			      (ido-read-file-name "Find file(as root): ")))
	 (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

     (defun buf-move-up ()
       "Swap the current buffer and the buffer above the split.
	   If there is no split, ie now window above the current one, an
	   error is signaled."
       ;;  "Switches between the current buffer, and the buffer above the
       ;;  split, if possible."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'up))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No window above this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-down ()
       "Swap the current buffer and the buffer under the split.
	   If there is no split, ie now window under the current one, an
	   error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'down))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (or (null other-win) 
		 (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
	     (error "No window under this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-left ()
       "Swap the current buffer and the buffer on the left of the split.
	   If there is no split, ie now window on the left of the current
	   one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'left))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No left split")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-right ()
       "Swap the current buffer and the buffer on the right of the split.
	   If there is no split, ie now window on the right of the current
	   one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'right))
	      (buf-this-buf (window-buffer (selected-window))))
	 (error "No right split")
	 ;; swap top with this one
	 (if (null other-win)
	     (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))
     (defun get-string-from-file (filePath)
       "Return filePath's file content."
       (with-temp-buffer
	 (insert-file-contents filePath)
	 (buffer-string)))
     (defun app-launcher (command)
       "Launches an application in your PATH.
	   Can show completions at point for COMMAND using helm or ido"
       (interactive (list (read-shell-command "$ ")))
       (start-process-shell-command command nil command))
   #+END_SRC
* Helm
  Helm stuff
** Init
   Helm init
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :config 
       (helm-autoresize-mode t)
       (setq helm-autoresize-max-height 30)
       (setq helm-display-header-line nil)
       (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
       (helm-mode t))
   #+END_SRC
* Evil Mode
  Evil Mode Settings
** Init
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :config 
       (evil-mode t)
       (setq evil-cross-lines t) ; For being able to use f and t across multiple lines of code making it 10x more 
       )
   #+END_SRC
** Insert-State
   For super simple editing of files without effort
   #+BEGIN_SRC emacs-lisp
     ;;     (general-define-key
     ;;      :states 'insert
     ;;      (kbd "C-n") 'previous-buffer)
   #+END_SRC
** Keybindings
   Keybindings for evil
   #+BEGIN_SRC emacs-lisp
     (use-package which-key)
     (which-key-mode)
     (evil-define-key '(normal) global-map (kbd ";") 'helm-M-x)
     (evil-define-key '(normal) global-map (kbd "SPC") 'app-launcher)
     (evil-define-key '(normal) global-map (kbd "gc") 'comment-line)
     (evil-define-key '(normal) global-map (kbd "z") 'projectile-command-map)
     (evil-define-key '(normal) global-map (kbd "\\") 'helm-projectile-rg)
     (evil-define-key '(normal) global-map (kbd "|") 'helm-projectile-find-file)
     (evil-define-key '(normal) global-map (kbd "`") 'magit-status)
     ;; Basic Movement @TODO(renzix): Maybe make this global period without defining what states can or cannot have this
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-h") 'evil-window-left)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-j") 'evil-window-down)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-k") 'evil-window-up)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-l") 'evil-window-right)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-v") 'evil-window-vsplit)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-s") 'evil-window-split)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-e") 'helm-find-files)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-H") 'evil-window-move-far-left)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-L") 'evil-window-move-far-right)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-J") 'evil-window-move-very-bottom)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-K") 'evil-window-move-very-top)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-d") 'evil-delete-buffer)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-D") 'delete-file-and-buffer)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M--") 'evil-window-decrease-height)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-=") 'evil-window-increase-height)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-_") 'evil-window-decrease-width)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-+") 'evil-window-increase-width)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-'") 'eshell)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-\"") 'vterm)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-Q") 'kill-emacs)
   #+END_SRC
* Programming
** Projectile
   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile)
     (projectile-mode t)
   #+END_SRC
** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit)
   #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode)
     (use-package cargo)
     (use-package racer)
     (use-package clippy)
     (add-hook 'rust-mode-hook #'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     (add-hook 'rust-mode-hook 'cargo-minor-mode)
     (setq rust-format-on-save t)

     (general-define-key
      :states '(normal)
      :keymaps 'rust-mode-map
      :prefix "," 
      (kbd "f") 'cargo-process-fmt
      (kbd "r") 'cargo-process-run
      (kbd "d") 'cargo-process-doc
      (kbd "o") 'cargo-process-doc-open
      (kbd "t") 'cargo-process-test
      (kbd "c") 'cargo-process-check
      (kbd "R") 'cargo-process-clean
      (kbd "n") 'cargo-process-new
      (kbd "u") 'cargo-process-update
      (kbd "b") 'cargo-process-build)
   #+END_SRC
** Python
   #+BEGIN_SRC emacs-lisp
     (use-package anaconda-mode
       :config 
       (add-hook 'python-mode-hook 'anaconda-mode)
       (add-hook 'python-mode-hook 'anaconda-eldoc-mode))
     (general-define-key
      :states '(normal)
      :keymaps 'python-mode-map
      :prefix "," 
      (kbd "d") 'python-eldoc-get-doc
      (kbd "l") 'python-check)
   #+END_SRC
** C/CPP 
   #+BEGIN_SRC emacs-lisp
     (use-package company-c-headers)
     (use-package irony
       :ensure t
       :defer t
       :init
       (add-hook 'c++-mode-hook 'irony-mode)
       (add-hook 'c-mode-hook 'irony-mode)
       (add-hook 'objc-mode-hook 'irony-mode)
       :config
       (defun my-irony-mode-hook ()
	 (define-key irony-mode-map [remap completion-at-point]
	   'irony-completion-at-point-async)
	 (define-key irony-mode-map [remap complete-symbol]
	   'irony-completion-at-point-async))
       (add-hook 'irony-mode-hook 'my-irony-mode-hook)
       (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
     ;;(general-define-key ;;C/CPP keys
     ;; :states '(normal motion)
     ;; :keymaps 'irony-mode-map
     ;; :prefix ",")
   #+END_SRC
** Lisp
   #+BEGIN_SRC emacs-lisp
     (setq inferior-lisp-program "/usr/bin/sbcl")
     (use-package slime)
     (use-package slime-company)
     (require 'slime-autoloads)
     (slime-setup '(slime-fancy))

   #+END_SRC
** Company
   @TODO(renzix): Switch from company to autocomplete for fuzzy matching???
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :defer t
       :init (add-hook 'after-init-hook 'global-company-mode)
       :config
       (use-package company-irony :ensure t :defer t)
       (use-package company-racer)
       (use-package company-anaconda)
       (setq company-idle-delay        2
	     company-minimum-prefix-length   2
	     company-show-numbers            t
	     company-tooltip-limit           20
	     company-dabbrev-downcase        nil
	     company-backends                '((company-irony company-gtags company-anaconda company-racer company-elisp company-nixos-options)))
       :bind ("C-<tab>" . company-indent-or-complete-common))
     (setq tab-always-indent 'complete)
   #+END_SRC
** Misc Programming
   @TODO(renzix): Make comments work idk why im writing this cuz im
   gonna delete this once i fix it anyway
   #+BEGIN_SRC emacs-lisp
     (use-package autopair
       :config (autopair-global-mode t))
     (use-package comment-tags
       :config
       (setq comment-tags-keyword-faces
	     `(("TODO" . ,(list :weight 'bold :foreground "#28ABE3"))
	       ("FIXME" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("BUG" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("HACK" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("KLUDGE" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("XXX" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("INFO" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("DONE" . ,(list :weight 'bold :foreground "#1FDA9A"))))
       (setq comment-tags-comment-start-only t
	     comment-tags-require-colon t
	     comment-tags-case-sensitive t
	     comment-tags-show-faces t
	     comment-tags-lighter nil)
       (add-hook 'prog-mode-hook 'comment-tags-mode))
     ;; Auto indent on save
     (defun indent-buffer ()
       (interactive)
       (save-excursion
	 (indent-region (point-min) (point-max) nil)))
     (add-hook 'before-save-hook 'indent-buffer)
   #+END_SRC
* Normal Tasks
** Text
   @TODO(renzix): Add spellcheck and autocorrect???
   #+BEGIN_SRC emacs-lisp
     (setq default-major-mode 'text-mode)
     (add-hook 'text-mode-hook 'text-mode-hook-identify)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+END_SRC
** Discord
   #+BEGIN_SRC emacs-lisp
     ;; For Rich presence
     (use-package elcord)
     ;; (elcord-mode)
   #+END_SRC
** IRC/Circe
   #+BEGIN_SRC emacs-lisp

     (setq circe-reduce-lurker-spam t
	   circe-network-options
	   '(("Freenode"
	      :nick "Renzix"
	      :channels ("#emacs" "#emacs-circe")
	      :nickserv-password ,freenode-password)
	     ("127.0.0.1"
	      :user "Renzix"
	      :port 6667
	      :channels ("#home" "#techsupport" "#devnull" "#wallpapers" "#bots" "#programming" 
			 "#anime" "#hardware" "#voice" "#ricing" "#de" "#wm" "#tools" "#feedback"
			 "#starboard" "#modlog" "#rules" "#announcements")
	      :pass discord-unixporn))
	   circe-format-say "{nick:-16s} {body}"
	   lui-time-stamp-position 'right-margin
	   lui-time-stamp-format "%H:%M")
     (enable-circe-color-nicks)
     (defun my-circe-set-margin ()
       (setq right-margin-width 5))
     (add-hook 'lui-mode-hook 'my-circe-set-margin)
     (defun my-circe-prompt ()
       (lui-set-prompt
	(concat (propertize (concat (buffer-name) ">")
			    'face 'circe-prompt-face)
		" ")))
     (add-hook 'circe-chat-mode-hook 'my-circe-prompt)
     (setq
      lui-time-stamp-position 'right-margin
      lui-fill-type nil)

     (add-hook 'lui-mode-hook 'my-lui-setup)
     (defun my-lui-setup ()
       (setq
	fringes-outside-margins t
	right-margin-width 5
	word-wrap t
	wrap-prefix "    "))
     (use-package circe)
     (use-package helm-circe)
     (use-package tracking)
     (general-define-key
      :states '(normal)
      :keymaps 'circe-mode-map
      :prefix ","
      (kbd ",") 'tracking-next-buffer
      (kbd "j") 'circe-command-JOIN
      (kbd "p") 'circe-command-PART
      (kbd "b") 'helm-circe)
   #+END_SRC
** Org
   #+BEGIN_SRC emacs-lisp
     (setq-default org-display-custom-times t)
     (setq org-export-date-timestamp-format '("%e %b %Y" . "<%a %b %e %Y %H:%M>"))
     (setq org-time-stamp-custom-formats '("%e %b %Y" . "<%a %b %e %Y %H:%M>"))
     (setq org-confirm-babel-evaluate nil)
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((org . t)
	(latex . t)
	(emacs-lisp . t)
	(sql . t)
	(shell . t)
	(python . t)))
     (general-define-key
      :states '(normal)
      :keymaps 'org-mode-map
      :prefix ","
      (kbd ",") 'org-export-dispatch
      (kbd "t") 'org-time-stamp
      (kbd "s") 'org-babel-execute-src-block
      (kbd "e") 'org-babel-execute-buffer
      (kbd "'") 'org-edit-special)
     (use-package ox-pandoc)
     (use-package htmlize)
   #+END_SRC
** KDE Connect
   #+BEGIN_SRC emacs-lisp
     (use-package kdeconnect)
   #+END_SRC
** Nix OS
   #+BEGIN_SRC emacs-lisp
     (use-package nix-mode)
     (use-package helm-nixos-options)
     (use-package company-nixos-options)
     (general-define-key
      :states '(normal)
      :keymaps 'nix-mode-map
      :prefix "," 
      (kbd "s") 'helm-nixos-options)
     ;; (general-define-key
     ;;       :states '(normal)
     ;;       :keymaps 'nix-mode-map
     ;;       (kbd "S-TAB") 'company-indent-or-complete-common)

   #+END_SRC
** Libvterm
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat HOME "/Projects/emacs-libvterm"))
     (let (vterm-install)
       (require 'vterm))
     (setq vterm-shell "ion")
   #+END_SRC
** Package Management
   #+BEGIN_SRC emacs-lisp
     (use-package system-packages)
     (use-package helm-system-packages
       :after (sysetem-packages))
   #+END_SRC
* Post Config
** Backups
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . "~/.saves"))
	   backup-by-copying t
	   delete-old-versions t
	   kept-new-versions 6
	   kept-old-versions 2
	   version-control t)
   #+END_SRC
** Misc
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
     (setq initial-buffer-choice 'eshell)
     ;; Theme stuff for emacs --daemon idk why it works  @TODO(renzix): Make this work
     (defvar my:theme 'apropospriate-dark)
     (defvar my:theme-window-loaded nil)
     (defvar my:theme-terminal-loaded nil)

     (if (daemonp)
	 (add-hook 'after-make-frame-functions(lambda (frame)
						(select-frame frame)
						(if (window-system frame)
						    (unless my:theme-window-loaded
						      (if my:theme-terminal-loaded
							  (enable-theme my:theme)
							(load-theme my:theme t))
						      (setq my:theme-window-loaded t))
						  (unless my:theme-terminal-loaded
						    (if my:theme-window-loaded
							(enable-theme my:theme)
						      (load-theme my:theme t))
						    (setq my:theme-terminal-loaded t)))))

       (progn
	 (load-theme my:theme t)
	 (if (display-graphic-p)
	     (setq my:theme-window-loaded t)
	   (setq my:theme-terminal-loaded t))))
     (setq org-src-tab-acts-natively t)
     ;; Need to wait till after everything for to start uwu
   #+END_SRC
   
