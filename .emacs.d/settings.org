//@TODO(renzix): Clean up  litterally everything
* Display
** Themes
   #+BEGIN_SRC emacs-lisp
     (use-package apropospriate-theme
       :ensure t
       :config (load-theme 'apropospriate-dark t))
   #+END_SRC
** Default Display
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC
* Pre Config
** General
   #+BEGIN_SRC emacs-lisp
     (use-package general
       :defer -1
       :config (general-evil-setup t))
     (defvar HOME (getenv "HOME"))
     (defvar WM nil)
     (setq warning-minimum-level :emergency)
   #+END_SRC
** Functions
   #+BEGIN_SRC emacs-lisp
     (defun eshell/clear ()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
	 (erase-buffer)
	 (eshell-send-input)))
     (defun kill-other-buffers ()
       "Kill all other buffers."
       (interactive)
       (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

     (defun rename-file-and-buffer (new-name)
       "Renames both current buffer and file it's visiting to NEW-NAME."
       (interactive "sNew name: ")
       (let ((name (buffer-name))
	     (filename (buffer-file-name)))
	 (if (not filename)
	     (message "Buffer '%s' is not visiting a file!" name)
	   (if (get-buffer new-name)
	       (message "A buffer named '%s' already exists!" new-name)
	     (progn
	       (rename-file filename new-name 1)
	       (rename-buffer new-name)
	       (set-visited-file-name new-name)
	       (set-buffer-modified-p nil))))))

     (defun delete-file-and-buffer ()
       "Kill the current buffer and deletes the file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
	 (when filename
	   (if (vc-backend filename)
	       (vc-delete-file filename)
	     (progn
	       (delete-file filename)
	       (message "Deleted file %s" filename)
	       (kill-buffer))))))

     (defun sudo-edit (&optional arg)
       (interactive "P")
       (if (or arg (not buffer-file-name))
	   (find-file (concat "/sudo:root@localhost:"
			      (ido-read-file-name "Find file(as root): ")))
	 (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

     (defun reset-erc-track-mode ()
       (interactive)
       (setq erc-modified-channels-alist nil)
       (erc-modified-channels-update))
     (global-set-key (kbd "C-c C-r") 'reset-erc-track-mode)

     (defun buf-move-up ()
       "Swap the current buffer and the buffer above the split.
      If there is no split, ie now window above the current one, an
      error is signaled."
       ;;  "Switches between the current buffer, and the buffer above the
       ;;  split, if possible."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'up))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No window above this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-down ()
       "Swap the current buffer and the buffer under the split.
      If there is no split, ie now window under the current one, an
      error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'down))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (or (null other-win) 
		 (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
	     (error "No window under this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-left ()
       "Swap the current buffer and the buffer on the left of the split.
      If there is no split, ie now window on the left of the current
      one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'left))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No left split")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-right ()
       "Swap the current buffer and the buffer on the right of the split.
      If there is no split, ie now window on the right of the current
      one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'right))
	      (buf-this-buf (window-buffer (selected-window))))
	 (error "No right split")
	 ;; swap top with this one
	 (if (null other-win)
	     (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))
     (defun get-string-from-file (filePath)
       "Return filePath's file content."
       (with-temp-buffer
	 (insert-file-contents filePath)
	 (buffer-string)))
     (defun app-launcher (command)
       "Launches an application in your PATH.
      Can show completions at point for COMMAND using helm or ido"
       (interactive (list (read-shell-command "$ ")))
       (start-process-shell-command command nil command))
   #+END_SRC
** EXWM
   #+name: EXWM
   #+BEGIN_SRC emacs-lisp
     ;;use https://pastebin.com/ba2WKNFS
     (if (boundp 'WM) (progn
			;;setup initial
			(use-package xelb)
			(use-package exwm)
			(exwm-enable)
			(setq exwm-workspace-number 4)
			(require 'exwm-randr)
			(setq exwm-randr-workspace-output-plist '(1 "DVI-D-0" 2 "DP-4" 3 "DP-3"))
			(add-hook 'exwm-randr-screen-change-hook
				  (lambda() 
				    (start-process-shell-command
				     "xrandr" nil "xrandr --output DVI-D-0 --left-of DP-4 --auto")
				    (start-process-shell-command
				     "xrandr" nil "xrandr --output DP-3 --right-of DP-4 --auto")))
			(exwm-randr-enable)))

     ;;Useful functions
     (defun exwm-bind-command (key command &rest bindings)
       (while key
	 (exwm-input-set-key (kbd key)
			     `(lambda ()
				(interactive)
				(start-process-shell-command ,command nil ,command)))
	 (setq key     (pop bindings)
	       command (pop bindings))))

     (defun exwm-input-line-mode ()
       "Set exwm window to line-mode and show mode line"
       (call-interactively #'exwm-input-grab-keyboard)
       (exwm-layout-show-mode-line))

     (defun exwm-input-char-mode ()
       "Set exwm window to char-mode and hide mode line"
       (call-interactively #'exwm-input-release-keyboard)
       (exwm-layout-hide-mode-line))

     (defun exwm-input-toggle-mode ()
       "Toggle between line- and char-mode"
       (with-current-buffer (window-buffer)
	 (when (eq major-mode 'exwm-mode)
	   (if (equal (second (second mode-line-process)) "line")
	       (exwm-input-char-mode)
	     (exwm-input-line-mode)))))

     (exwm-input-set-key (kbd "s-i")
			 (lambda () (interactive)
			   (exwm-input-toggle-mode)))
     (defvar exwm-app-launcher--prompt "$ "
       "Prompt for the EXWM application launcher")
     (defun exwm-application-launcher (command)
       "Launches an application in your PATH.
      Can show completions at point for COMMAND using helm or ido"
       (interactive (list (read-shell-command exwm-app-launcher--prompt)))
       (start-process-shell-command command nil command))
     ;;Misc
     ;; Rename buffer to window title
     (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
     (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)

     ;;Applications @TODO(renzix): Fix this
     (exwm-bind-command "<s-return>" "urxvt")
     (exwm-bind-command "s-i" "firefox")
     ;;Keybindings
     ;;Workspace keys
     (dotimes (i 10)
       (exwm-input-set-key (kbd (format "s-%d" i))
			   `(lambda ()
			      (interactive)
			      (exwm-workspace-switch-create ,i))))

     (exwm-input-set-key (kbd "s-S-w") 'exwm-workspace-move-window)
     (exwm-input-set-key (kbd "s-C-w") 'exwm-workspace-swap)
     (exwm-input-set-key (kbd "s-SPC") #'exwm-application-launcher)
     (exwm-input-set-key (kbd "s-r") 'exwm-reset)
     (exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)
     (exwm-input-set-key (kbd "s-f") #'exwm-layout-toggle-fullscreen)
     (exwm-input-set-key (kbd "s-q") 'kill-emacs)
     (exwm-input-set-key (kbd "s-;") 'helm-M-x)
     (exwm-input-set-key (kbd "s-:") 'evil-ex)
     (exwm-input-set-key (kbd "s-b") #'helm-mini)
     ;; Focusing windows
     (exwm-input-set-key (kbd "s-h") #'evil-window-left)
     (exwm-input-set-key (kbd "s-j") #'evil-window-down)
     (exwm-input-set-key (kbd "s-k") #'evil-window-up)
     (exwm-input-set-key (kbd "s-l") #'evil-window-right)
     ;; Moving Windows
     (exwm-input-set-key (kbd "s-H") #'evil-window-move-far-left)
     (exwm-input-set-key (kbd "s-J") #'evil-window-move-very-bottom)
     (exwm-input-set-key (kbd "s-K") #'evil-window-move-very-top)
     (exwm-input-set-key (kbd "s-L") #'evil-window-move-far-right)
     ;;(kbd "s-k") (lambda () (interactive) (exwm-input-toggle-keyboard))
     ;;Gets rid of Async displaybuffer
     (add-to-list 'display-buffer-alist
		  (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))
   #+END_SRC

* Helm
** Init
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :config 
       (helm-autoresize-mode t)
       (setq helm-autoresize-max-height 30)
       (setq helm-display-header-line nil)
       (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
       (helm-mode t))
   #+END_SRC
* Evil Mode
** Settings
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :config (evil-mode t))
   #+END_SRC
** Linum Relative
   #+BEGIN_SRC emacs-lisp
     (use-package linum-relative)
     (linum-mode)
     (linum-relative-global-mode)
     (setq linum-relative-current-symbol "")
     (set-face-attribute 'linum nil :height 100)
     (set-face-attribute 'linum-relative-current-face nil :height 100)
     (defun linum-update-window-scale-fix (win)
       "fix linum for scaled text"
       (set-window-margins win
			   (ceiling (* (if (boundp 'text-scale-mode-step)
					   (expt text-scale-mode-step
						 text-scale-mode-amount) 1)
				       (if (car (window-margins))
					   (car (window-margins)) 1)
				       ))))
     (advice-add #'linum-update-window :after #'linum-update-window-scale-fix)
   #+END_SRC
** Evil-Window-State
   #+BEGIN_SRC emacs-lisp
     ;; First define window-mode-map
     (evil-define-state buffer
       "Buffer state. Moves and opens windows"
       :tag " <B> "
       :message " -- BUFFER -- "
       :exit-hook (evil-buffer-stop-hook))
     (defun buffer-mode ()
       (interactive)
       ;; Put into window-mode-map
       (evil-window-map)
       )

     (defun evil-buffer-stop-hook ()
       ;; Exit window-mode-map
       (evil-window-map)
       )
   #+END_SRC
** Keybindings
   #+BEGIN_SRC emacs-lisp
     (use-package which-key)
     (which-key-mode)
     (evil-define-key 'normal global-map (kbd ";") 'helm-M-x)
     (evil-define-key 'normal global-map (kbd "SPC") 'app-launcher)
     (evil-define-key 'buffer global-map (kbd "ESC") 'normal-mode)
     (evil-define-key 'normal global-map (kbd "\\") 'buffer-mode)
     (evil-ex-define-cmd "bb" 'helm-buffers-list)
     (evil-ex-define-cmd "bk" 'kill-buffer)
     (evil-ex-define-cmd "pp" 'helm-projectile-switch-project)
     (evil-ex-define-cmd "pc" 'projectile-compile-project)
     (evil-ex-define-cmd "pt" 'projectile-test-project)
     (evil-ex-define-cmd "pf" 'helm-projectile-find-file)
     (evil-ex-define-cmd "pb" 'helm-projectile-switch-to-buffer)
     (evil-ex-define-cmd "ps" 'helm-projectile-rg)
     (evil-ex-define-cmd "fd" 'delete-file-and-buffer)
     ;; Some other keybinds 
     (evil-ex-define-cmd "q" 'kill-this-buffer)
     (evil-ex-define-cmd "qe" 'evil-quit)
     (evil-ex-define-cmd "e" 'helm-find-files)
     (evil-ex-define-cmd "ee" 'evil-edit)
     (evil-ex-define-cmd "q" 'kill-buffer-and-window)
     (evil-ex-define-cmd "qb" 'kill-this-buffer)
     (evil-ex-define-cmd "qe" 'kill-emacs)
     (evil-ex-define-cmd "qw" 'evil-window-delete)
     ;; Kill-buffer C-x k
     ;; WINDOW MODE BINDINGS
     (general-define-key
      :states 'normal
      :prefix "|"
      (kbd "'") 'eshell
      (kbd "\"") 'term
      (kbd "c") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file (concat HOME "/.emacs.d/settings.org") t) ))
      (kbd "i") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file (concat HOME "/.emacs.d/init.el"))))
      (kbd "b") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file (concat HOME "/.config/bspwm/bspwmrc"))))
      (kbd "s") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file (concat HOME "/.config/sxhkd/sxhkdrc_bspwm"))))
      (kbd "m") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file "/sudo::/etc/portage/make.conf")))
      (kbd "d") (lambda() (interactive) (let ((default-directory (concat HOME "/Dotfiles"))(magit-pull-from-upstream "master")) (find-file "/sudo::/etc/portage/savedconfig/x11-wm/dwm-6.1-r1.h"))))
     ;; INSERT MODE BINDINGS
     (general-define-key
      :states 'normal
      (kbd "C-b") 'helm-find-files)
   #+END_SRC
* Programming
** Projectile
   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile)
     (projectile-mode +1)
     (general-define-key
      :states '(normal)
      :prefix "|"
      (kbd "\\") 'projectile-command-map)
   #+END_SRC
** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit)
   #+END_SRC
** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :defer t
       :init (add-hook 'after-init-hook 'global-company-mode)
       :config
       (use-package company-irony :ensure t :defer t)
       (setq company-idle-delay        2
	     company-minimum-prefix-length   2
	     company-show-numbers            t
	     company-tooltip-limit           20
	     company-dabbrev-downcase        nil
	     company-backends                '((company-irony company-gtags company-anaconda company-racer company-elisp)))
       :bind ("TAB" . company-indent-or-complete-common))
     (setq tab-always-indent 'complete)
   #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode)
     (use-package cargo)
     (use-package racer)
     (use-package company-racer)
     (add-hook 'rust-mode-hook #'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     (add-hook 'rust-mode-hook 'cargo-minor-mode)
     (setq rust-format-on-save t)

     (general-define-key
      :states '(normal)
      :keymaps 'rust-mode-map
      :prefix "," 
      (kbd "f") 'cargo-process-fmt
      (kbd "r") 'cargo-process-run
      (kbd "d") 'cargo-process-doc
      (kbd "o") 'cargo-process-doc-open
      (kbd "t") 'cargo-process-test
      (kbd "c") 'cargo-process-check
      (kbd "R") 'cargo-process-clean
      (kbd "n") 'cargo-process-new
      (kbd "u") 'cargo-process-update
      (kbd "b") 'cargo-process-build)
   #+END_SRC
** Python
   #+BEGIN_SRC emacs-lisp
     (add-hook 'python-mode-hook 'anaconda-mode)
     (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
     (general-define-key
      :states '(normal)
      :keymaps 'python-mode-map
      :prefix "," 
      (kbd "d") 'python-eldoc-get-doc
      (kbd "l") 'python-check)
   #+END_SRC
** C/CPP 
   #+BEGIN_SRC emacs-lisp
     (use-package irony
       :ensure t
       :defer t
       :init
       (add-hook 'c++-mode-hook 'irony-mode)
       (add-hook 'c-mode-hook 'irony-mode)
       (add-hook 'objc-mode-hook 'irony-mode)
       :config
       (defun my-irony-mode-hook ()
	 (define-key irony-mode-map [remap completion-at-point]
	   'irony-completion-at-point-async)
	 (define-key irony-mode-map [remap complete-symbol]
	   'irony-completion-at-point-async))
       (add-hook 'irony-mode-hook 'my-irony-mode-hook)
       (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
     (general-define-key ;;C/CPP keys
      :states '(normal)
      :keymaps 'irony-mode-map
      :prefix ",")
   #+END_SRC
** Misc Programming
   #+BEGIN_SRC emacs-lisp
     (use-package autopair
       :config (autopair-global-mode t))
     (use-package comment-tags)
     (autoload 'comment-tags-mode "comment-tags-mode")
     (setq comment-tags-keymap-prefix (kbd "C-c t"))
     (with-eval-after-load "comment-tags"
       (setq comment-tags-keyword-faces
	     `(("TODO" . ,(list :weight 'bold :foreground "#28ABE3"))
	       ("FIXME" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("BUG" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("HACK" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("KLUDGE" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("XXX" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("INFO" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("DONE" . ,(list :weight 'bold :foreground "#1FDA9A"))))
       (setq comment-tags-comment-start-only t
	     comment-tags-require-colon t
	     comment-tags-case-sensitive t
	     comment-tags-show-faces t
	     comment-tags-lighter nil))
     (add-hook 'prog-mode-hook 'comment-tags-mode)
   #+END_SRC
* Normal Tasks
** ERC
   #+BEGIN_SRC emacs-lisp
     (setq erc-hide-list '("JOIN" "PART" "QUIT" "ROOT"))
     (setq erc-kill-buffer-on-part t)
     (setq erc-kill-queries-on-quit t)
     (setq erc-kill-server-buffer-on-quit t)

     (defmacro erc-connect (command server port nick ssl pass)
       "Create interactive command `command', for connecting to an IRC server. The
      command uses interactive mode if passed an argument."
       (fset command
	     `(lambda (arg)
		(interactive "p")
		(if (not (= 1 arg))
		    (call-interactively 'erc)
		  (let ((erc-connect-function ',(if ssl 'erc-open-ssl-stream 'open-network-stream)))
		    (erc :server ,server :port ,port :nick ,nick :password ,pass))))))
     (erc-connect bitlbee-erc "127.0.0.1" 6667 "Renzix" nil "Akeyla10!")
     (erc-connect twitch-erc "irc.chat.twitch.tv" 6667 "TheRenzix" nil (get-string-from-file (concat HOME "/.config/twitch-oauth")))
     (general-define-key
      :states '(normal)
      :keymaps 'erc-mode-map
      :prefix ","
      (kbd "b") 'erc-switch-to-buffer
      (kbd "q") 'erc-quit-server
      (kbd "p") 'erc-part-from-channel
      (kbd "j") 'erc-join-channel
      (kbd ",") 'erc-track-switch-buffer)
   #+END_SRC

** Text
   #+BEGIN_SRC emacs-lisp
     (setq default-major-mode 'text-mode)
     (add-hook 'text-mode-hook 'text-mode-hook-identify)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+END_SRC
** Discord
   #+BEGIN_SRC emacs-lisp
     ;; For Rich presence
     (use-package elcord)
     (setq elcord-mode t)
   #+END_SRC
** Org
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((org . t)
	(latex . t)
	(emacs-lisp . t)
	(sql . t)))
     (general-define-key
      :states '(normal)
      :keymaps 'org-mode-map
      :prefix ","
      (kbd ",") 'org-export-dispatch
      (kbd "t") 'org-time-stamp)

   #+END_SRC
* Post Config
** Backups
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . "~/.saves")))
     (setq backup-by-copying t)
     (setq delete-old-versions t
	   kept-new-versions 6
	   kept-old-versions 2
	   version-control t)
   #+END_SRC
** Misc
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
     (setq initial-buffer-choice 'eshell)
					     ; Theme stuff for emacs --daemon idk why it works 
     (defvar my:theme 'apropospriate-dark)
     (defvar my:theme-window-loaded nil)
     (defvar my:theme-terminal-loaded nil)

     (if (daemonp)
	 (add-hook 'after-make-frame-functions(lambda (frame)
						(select-frame frame)
						(if (window-system frame)
						    (unless my:theme-window-loaded
						      (if my:theme-terminal-loaded
							  (enable-theme my:theme)
							(load-theme my:theme t))
						      (setq my:theme-window-loaded t))
						  (unless my:theme-terminal-loaded
						    (if my:theme-window-loaded
							(enable-theme my:theme)
						      (load-theme my:theme t))
						    (setq my:theme-terminal-loaded t)))))

       (progn
	 (load-theme my:theme t)
	 (if (display-graphic-p)
	     (setq my:theme-window-loaded t)
	   (setq my:theme-terminal-loaded t))))
     (setq org-src-tab-acts-natively t)
     (toggle-frame-maximized)
   #+END_SRC
