* Display
  Makes emacs look good by theme and gets rid of toolbar stuff
** Themes
   Choose Theme
   #+BEGIN_SRC emacs-lisp
     (use-package apropospriate-theme)
     (use-package nord-theme);
     ;; :config (load-theme 'nord nil))
     (load-theme 'apropospriate-dark t)
   #+END_SRC
** Some Defaults
   Gets rid of default options for display
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (display-battery-mode)
     (display-time)
   #+END_SRC
** Lines
   Makes VI relative line numbering
   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode)
     (setq-default display-line-numbers-type 'relative
		   display-line-numbers-current-absolute t
		   display-line-numbers-width 4
		   display-line-numbers-widen t)
   #+END_SRC
* Pre Config
  Preconfiguration. For stuff before actual config like variables
** General
   #+BEGIN_SRC emacs-lisp
     ;; @TODO(automatically get use-package
     (use-package quelpa
       :init '(setq quelpa-upgrade-p t
		    quelpa-stable-p t))
     (use-package quelpa-use-package)
     (use-package general
       :config (general-evil-setup t))
     (defvar HOME (getenv "HOME"))
     (defvar WM nil)
     (load-file (concat HOME "/.emacs.d/private.el"))
   #+END_SRC
** Functions
   Useful function
   #+BEGIN_SRC emacs-lisp
     (defun open-emacs-config ()
       "Opens my emacs config uwu"
       (interactive)
       (find-file (concat HOME "/.emacs.d/settings.org")))
     (defun org-get-keyword (KEYWORD)
       "get the value from a line like this
     ,#+KEYWORD: value
     in a file."
       (interactive)
       (let ((case-fold-search t)
	     (re (format "^#\\+%s:[ \t]+\\([^\t\n]+\\)" KEYWORD)))
	 (if (not (save-excursion
		    (or (re-search-forward re nil t)
			(re-search-backward re nil t))))
	     (error (format "No line containing #+%s: value found" KEYWORD)))
	 (match-string 1)))

     (defun eshell/clear ()
       "Clear the eshell buffer."
       (let ((inhibit-read-only t))
	 (erase-buffer)
	 (eshell-send-input)))
     (defun kill-other-buffers ()
       "Kill all other buffers."
       (interactive)
       (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

     (defun rename-file-and-buffer (new-name)
       "Renames both current buffer and file it's visiting to NEW-NAME."
       (interactive "New name: ")
       (let ((name (buffer-name))
	     (filename (buffer-file-name)))
	 (if (not filename)
	     (message "Buffer '%s' is not visiting a file!" name)
	   (if (get-buffer new-name)
	       (message "A buffer named '%s' already exists!" new-name)
	     (progn
	       (rename-file filename new-name 1)
	       (rename-buffer new-name)
	       (set-visited-file-name new-name)
	       (set-buffer-modified-p nil))))))

     (defun delete-file-and-buffer ()
       "Kill the current buffer and deletes the file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
	 (when filename
	   (if (vc-backend filename)
	       (vc-delete-file filename)
	     (progn
	       (delete-file filename)
	       (message "Deleted file %s" filename)
	       (kill-buffer))))))

     (defun sudo-edit (&optional arg)
       (interactive "P")
       (if (or arg (not buffer-file-name))
	   (find-file (concat "/sudo:root@localhost:"
			      (ido-read-file-name "Find file(as root): ")))
	 (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

     (defun buf-move-up ()
       "Swap the current buffer and the buffer above the split.
	   If there is no split, ie now window above the current one, an
	   error is signaled."
       ;;  "Switches between the current buffer, and the buffer above the
       ;;  split, if possible."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'up))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No window above this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-down ()
       "Swap the current buffer and the buffer under the split.
	   If there is no split, ie now window under the current one, an
	   error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'down))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (or (null other-win) 
		 (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
	     (error "No window under this one")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-left ()
       "Swap the current buffer and the buffer on the left of the split.
	   If there is no split, ie now window on the left of the current
	   one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'left))
	      (buf-this-buf (window-buffer (selected-window))))
	 (if (null other-win)
	     (error "No left split")
	   ;; swap top with this one
	   (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))

     (defun buf-move-right ()
       "Swap the current buffer and the buffer on the right of the split.
	   If there is no split, ie now window on the right of the current
	   one, an error is signaled."
       (interactive)
       (let* ((other-win (windmove-find-other-window 'right))
	      (buf-this-buf (window-buffer (selected-window))))
	 (error "No right split")
	 ;; swap top with this one
	 (if (null other-win)
	     (set-window-buffer (selected-window) (window-buffer other-win))
	   ;; move this one to top
	   (set-window-buffer other-win buf-this-buf)
	   (select-window other-win))))
     (defun get-string-from-file (filePath)
       "Return filePath's file content."
       (with-temp-buffer
	 (insert-file-contents filePath)
	 (buffer-string)))
     (defun app-launcher (command)
       "Launches an application in your PATH.
	   Can show completions at point for COMMAND using helm or ido"
       (interactive (list (read-shell-command "$ ")))
       (start-process-shell-command command nil command))
   #+END_SRC
* Helm
  Helm stuff
** Init
   Helm init!
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :config 
       (helm-autoresize-mode t)
       (setq helm-autoresize-max-height 30)
       (setq helm-display-header-line nil)
       (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
       (helm-mode t))
   #+END_SRC
* Evil Mode
  Evil Mode Settings
** Init
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :config 
       (evil-mode t)
       (setq evil-cross-lines t) ; For being able to use f and t across multiple lines of code making it 10x more 
       )
   #+END_SRC
** Keybindings
   My keybindings for evil
   #+BEGIN_SRC emacs-lisp
     (use-package which-key)
     (which-key-mode)
     (evil-define-key '(normal) global-map (kbd ";") 'helm-M-x)
     (evil-define-key '(normal) global-map (kbd "SPC") 'helm-run-external-command)
     (evil-define-key '(normal) global-map (kbd "gc") 'comment-line)
     (evil-define-key '(normal) global-map (kbd "z") 'projectile-command-map)
     (evil-define-key '(normal) global-map (kbd "\\") 'helm-projectile-rg)
     (evil-define-key '(normal) global-map (kbd "|") 'helm-projectile-find-file)
     (evil-define-key '(normal) global-map (kbd "`") 'magit-status)
     ;; Basic Movement @TODO(renzix): Maybe make this global period without defining what states can or cannot have this
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-h") 'evil-window-left)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-j") 'evil-window-down)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-k") 'evil-window-up)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-l") 'evil-window-right)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-v") 'evil-window-vsplit)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-s") 'evil-window-split)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-e") 'helm-find-files)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-H") 'evil-window-move-far-left)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-L") 'evil-window-move-far-right)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-J") 'evil-window-move-very-bottom)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-K") 'evil-window-move-very-top)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-b") 'helm-bookmarks)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-q") 'helm-locate)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-d") 'evil-delete-buffer)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-D") 'delete-file-and-buffer)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M--") 'evil-window-decrease-height)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-=") 'evil-window-increase-height)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-_") 'evil-window-decrease-width)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-+") 'evil-window-increase-width)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-'") 'eshell)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-\"") 'vterm)
     (evil-define-key '(normal insert motion visual) global-map (kbd "M-Q") 'kill-emacs)
     ;; EX Commands that may or maynot stay forever once i decide on the best way to define keybinds
     (evil-ex-define-cmd "em" 'helm-find-files)
     (evil-ex-define-cmd "bl" 'helm-buffers-list)
     (evil-ex-define-cmd "bm" 'helm-bookmarks)
     (evil-ex-define-cmd "fd" 'delete-file-and-buffer)
     (evil-ex-define-cmd "es" 'eshell)
     (evil-ex-define-cmd "te" 'vterm)
     (evil-ex-define-cmd "lc" 'helm-locate)
     (evil-ex-define-cmd "h" 'evil-window-left)
     (evil-ex-define-cmd "j" 'evil-window-down)
     (evil-ex-define-cmd "k" 'evil-window-up)
     (evil-ex-define-cmd "l" 'evil-window-right)
     (evil-ex-define-cmd "mh" 'evil-window-move-far-left)
     (evil-ex-define-cmd "mj" 'evil-window-move-very-bottom)
     (evil-ex-define-cmd "mk" 'evil-window-very-top)
     (evil-ex-define-cmd "ml" 'evil-window-far-right)
     (evil-ex-define-cmd "kr" 'helm-show-kill-ring)
     (evil-ex-define-cmd "nn" 'tracking-next-buffer)
     (evil-ex-define-cmd "pn" 'tracking-previous-buffer)
     (evil-ex-define-cmd "cfg" 'open-emacs-config)
   #+END_SRC
* Programming
** Company
   #+BEGIN_SRC emacs-lisp
     (use-package company)
     (add-hook 'after-init-hook 'global-company-mode)
     (setq company-require-match 'never
	   company-minimum-prefix-length 0
	   company-tooltip-align-annotations t
	   company-idle-delay .3
	   company-dabbrev-downcase 0
	   company-tooltip-limit 20
	   global-company-mode t)
     (eval-after-load 'company
       '(progn
	  (define-key company-active-map (kbd "S-TAB") 'company-select-previous)
	  (define-key company-active-map (kbd "<backtab>") 'company-select-previous)
	  (define-key company-active-map (kbd "TAB") 'company-complete-common-or-cycle)
	  (define-key company-active-map (kbd "<return>") nil)
	  (define-key company-active-map (kbd "RET") nil)
	  (define-key company-active-map (kbd "C-SPC") #'company-complete-selection)
	  (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)))
   #+END_SRC
** Projectile
   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile)
     (projectile-mode t)
   #+END_SRC
** Magit
   #+BEGIN_SRC emacs-lisp
     (use-package evil-magit)
     ;;(use-package forge ; @TODO(renzix): When this gets stable i should use it uwu
     ;;  :after evil-magit)
   #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode)
     (use-package rustic)
     (use-package cargo)
     (use-package lsp-mode)
     (use-package clippy)
     (use-package racer
       :init (setq racer-rust-src-path
		   (concat (string-trim
			    (shell-command-to-string "rustc --print sysroot"))
			   "/lib/rustlib/src/rust/src")))
     (setq rustic-format-on-save t)
     (add-hook 'rust-mode-hook #'racer-mode)
     (add-hook 'racer-mode-hook #'eldoc-mode)
     ;;(add-hook 'racer-mode-hook 'company-mode)

     (general-define-key
      :keymaps 'projectile-mode-map
      :prefix "z r"
      (kbd "c") 'rustic-cargo-build
      (kbd "C") 'rustic-recompile
      (kbd "p") 'rustic-popup
      (kbd "t") 'rustic-cargo-test
      (kbd "r") 'rustic-cargo-run
      (kbd "o") 'rustic-cargo-outdated)

     (general-define-key
      :states '(normal)
      :keymaps 'rustic-mode-map
      :prefix "," 
      (kbd ".") 'racer-find-definition
      (kbd "S-.") 'racer-find-definition-other-window
      (kbd "d") 'racer-describe-tooltip
      (kbd "f") 'rustic-format-buffer)
   #+END_SRC
** Python
   #+BEGIN_SRC emacs-lisp
     (use-package company-jedi)

     ;;(add-hook 'python-mode-hook 'company-mode)
     (add-hook 'python-mode-hook 'flycheck-mode)
     (eval-after-load 'company
       '(add-to-list 'company-backends 'company-jedi))


     (general-define-key
      :states '(normal)
      :keymaps 'python-mode-map
      :prefix "," 
      (kbd "d") 'jedi:show-doc
      (kbd ".") 'jedi:goto-definition
      (kbd "c") 'python-check)
   #+END_SRC
** C/CPP 
   #+BEGIN_SRC emacs-lisp
     (use-package irony)
     (use-package flycheck-irony)
     (use-package irony-eldoc)
     (use-package company-irony)
     (use-package company-irony-c-headers)
     (add-hook 'c++-mode-hook 'irony-mode)
     (add-hook 'c-mode-hook 'irony-mode)
     (add-hook 'objc-mode-hook 'irony-mode)

     ;;(add-hook 'irony-mode-hook 'company-mode)
     (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
     (add-hook 'irony-mode-hook #'irony-eldoc)
     (add-hook 'irony-mode-hook 'flycheck-mode)
     (add-hook 'flycheck-mode-hook #'flycheck-irony-setup)

     (eval-after-load 'company
       '(add-to-list 'company-backends 'company-irony))

     (defadvice find-tag (around refresh-etags activate)
       "Rerun etags and reload tags if tag not found and redo find-tag.              
      If buffer is modified, ask about save before running etags."
       (let ((extension (file-name-extension (buffer-file-name))))
	 (condition-case err
	     ad-do-it
	   (error (and (buffer-modified-p)
		       (not (ding))
		       (y-or-n-p "Buffer is modified, save it? ")
		       (save-buffer))
		  (er-refresh-etags extension)
		  ad-do-it))))


     (defun er-refresh-etags (&optional extension)
       "Run etags on all peer files in current dir and reload them silently."
       (interactive)
       (shell-command (format "etags *.%s" (or extension "el")))
       (let ((tags-revert-without-query t))  ; don't query, revert silently          
	 (visit-tags-table default-directory nil)))

     (general-define-key ;;C/CPP keys
      :states '(normal motion)
      :keymaps 'irony-mode-map
      :prefix ","
      (kbd ".") 'xref-find-definition
      (kbd "S-.") 'xref-find-definition-other-window
      (kbd "h") 'ff-find-other-file)
   #+END_SRC
** Lisp
   #+BEGIN_SRC emacs-lisp
     ;;(setq inferior-lisp-program "/usr/bin/sbcl")
     ;;(use-package slime)
     ;;(require 'slime-autoloads)
     ;;(slime-setup '(slime-fancy))
   #+END_SRC
** Misc Programming
   @TODO(renzix): Make comments work idk why im writing this cuz im
   gonna delete this once i fix it anyway
   #+BEGIN_SRC emacs-lisp
     (use-package autopair
       :config (autopair-global-mode t))
     (use-package comment-tags
       :config
       (setq comment-tags-keyword-faces
	     `(("TODO" . ,(list :weight 'bold :foreground "#28ABE3"))
	       ("FIXME" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("BUG" . ,(list :weight 'bold :foreground "#DB3340"))
	       ("HACK" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("KLUDGE" . ,(list :weight 'bold :foreground "#E8B71A"))
	       ("XXX" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("INFO" . ,(list :weight 'bold :foreground "#F7EAC8"))
	       ("DONE" . ,(list :weight 'bold :foreground "#1FDA9A"))))
       (setq comment-tags-comment-start-only t
	     comment-tags-require-colon t
	     comment-tags-case-sensitive t
	     comment-tags-show-faces t
	     comment-tags-lighter nil)
       (add-hook 'prog-mode-hook 'comment-tags-mode))
     ;; Auto indent on save
     (defun indent-buffer ()
       (interactive)
       (save-excursion
	 (indent-region (point-min) (point-max) nil)))
     (add-hook 'before-save-hook 'indent-buffer)
   #+END_SRC
* Normal Tasks
** Text
   @TODO(renzix): Add spellcheck and autocorrect???
   #+BEGIN_SRC emacs-lisp
     (setq default-major-mode 'text-mode)
     (add-hook 'text-mode-hook 'text-mode-hook-identify)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   #+END_SRC
** pb
   @TODO(renzix): Make this into a seperate package???
   @TODO(renzix): Add text support for buffer, file and selection
   #+BEGIN_SRC emacs-lisp
     (defun pb-selection (&optional beg end)
       "Takes a picture based on mouse"
       (interactive (if (use-region-p)
			(list (region-beginning)
			      (region-end))
		      (list (point-min)
			    (point-max))))
       (let ((res (pb--post (buffer-substring beg end))))
	 (kill-new res)
	 (message res)))
     (defun pb-file (file)
       "Takes a picture based on mouse"
       (interactive "fUploaded File: ")
       (let ((res (concat (pb--post (get-string-from-file file)) (file-name-extension))))
	 (kill-new res)
	 (message res)))
     (defun pb-png () ;@TODO(renzix): Doesnt work i need to fix this
       "Takes a picture based on mouse"
       (interactive)
       (let ((res (concat (pb--post (shell-command-to-string "maim -sq")) ".png")))
	 (kill-new res)
	 (message res)))
     (defun pb-get (&optional url) 
       "gets content in a new buffer" 
       (interactive (list (if 
			      (and (not (zerop (length kill-ring))) (string-match-p "http*" (current-kill 0)))
			      (read-string (format "Website Url(%s): " (current-kill 0))) 
			    (read-string "Website Url: "))))
       (if (= (length url) 0) 
	   (browse-url-emacs (current-kill 0))
	 (browse-url-emacs url)))

     (defun pb--post (input) ;get this working almost perfectly
       "Raw pb post function accepts a buncha params"
       (let* ((url "https://ptpb.pw/")
	      (url-request-method "POST")
	      (url-request-extra-headers
	       '(("Content-Type" . "application/x-www-form-urlencoded")))
	      (url-request-data))
	 (setq url-request-data (pb--urlencode `(("c" . ,input))))
	 (with-current-buffer (url-retrieve-synchronously url)
	   (goto-char (point-min))
	   (re-search-forward "https://*" nil t)
	   (buffer-substring (point) (point-at-eol)))))
     (defun pb--urlencode (alis)
       "Map an alist of key/value pairs to an URL-encoded string."
       (mapconcat (lambda (pair)
		    (format "%s=%s"
			    (url-hexify-string
			     (format "%s" (car pair)))
			    (url-hexify-string
			     (format "%s" (if (consp (cdr pair))
					      (cadr pair)
					    (cdr pair))))))
		  alis
		  "&"))
   #+END_SRC

   #+RESULTS:
   : pb--urlencode

** emms/twitch
   #+BEGIN_SRC emacs-lisp
     (use-package emms)
     (emms-all)
     (emms-default-players)
     (use-package helm-twitch ; @TODO(renzix): Work on this to make it useable with emms
       :quelpa (helm-twitch :fetcher github :repo "Renzix/helm-twitch"))
   #+END_SRC
** Discord
   #+BEGIN_SRC emacs-lisp
     ;; For Rich presence
     (use-package elcord)
     (elcord-mode)
   #+END_SRC
** Matrix
   wtf the emacs matrix client is fucking lit
   #+BEGIN_SRC emacs-lisp
     (setq matrix-client-show-images t
	   matrix-client-show-room-avatars t
	   matrix-client-mark-modified-rooms t
	   matrix-client-use-tracking t
	   matrix-client-render-presence t
	   matrix-client-render-membership t)
     (use-package matrix-client
       :quelpa ((matrix-client :fetcher github :repo "alphapapa/matrix-client.el"
			       :files (:defaults "logo.png" "matrix-client-standalone.el.sh"))))
     (general-define-key
      :states '(normal)
      :prefix "M-z"
      (kbd ",") 'tracking-previous-buffer
      (kbd ".") 'tracking-next-buffer
      (kbd "o") 'matrix-client-upload
      (kbd "b") 'matrix-client-switch-buffer)
   #+END_SRC
** IRC/Circe
   #+BEGIN_SRC emacs-lisp
     (setq circe-reduce-lurker-spam t
	   circe-network-options
	   '(("Freenode"
	      :nick "Renzix"
	      :channels (:after-auth "#emacs" "#emacs-circe" "#unixporn" "#gentoo" "##cordance")
	      :nickserv-nick "Renzix"
	      :nickserv-password freenode-password)
	     ("127.0.0.1"
	      :user "Renzix"
	      :port 6667
	      :channels ("#home" "#techsupport" "#devnull" "#wallpapers" "#bots" "#programming" 
			 "#anime" "#hardware" "#voice" "#ricing" "#de" "#wm" "#tools" "#feedback"
			 "#starboard" "#modlog" "#rules" "#announcements")
	      :pass discord-unixporn))
	   circe-format-say "{nick:-16s} {body}"
	   lui-time-stamp-position 'right-margin
	   lui-time-stamp-format "%H:%M")
     (enable-circe-color-nicks)
     (defun my-circe-set-margin ()
       (setq right-margin-width 5))
     (add-hook 'lui-mode-hook 'my-circe-set-margin)
     (defun my-circe-prompt ()
       (lui-set-prompt
	(concat (propertize (concat (buffer-name) ">")
			    'face 'circe-prompt-face)
		" ")))
     (add-hook 'circe-chat-mode-hook 'my-circe-prompt)
     (setq
      lui-time-stamp-position 'right-margin
      lui-fill-type nil)

     (add-hook 'lui-mode-hook 'my-lui-setup)
     (defun my-lui-setup ()
       (setq
	fringes-outside-margins t
	right-margin-width 5
	word-wrap t
	wrap-prefix "    "))
     (use-package circe)
     (use-package helm-circe)
     (use-package tracking)
     (general-define-key
      :states '(normal)
      :keymaps 'circe-mode-map
      :prefix ","
      (kbd ",") 'tracking-next-buffer
      (kbd "j") 'circe-command-JOIN
      (kbd "p") 'circe-command-PART
      (kbd "b") 'helm-circe)
   #+END_SRC
** Org
   Some basic configuration for org mode incluing access to executing
   python,sql,emacs-lisp and latex. Also some keybinds
   #+BEGIN_SRC emacs-lisp
     (setq-default org-display-custom-times t)
     (setq org-export-date-timestamp-format '("%e %b %Y" . "<%a %b %e %Y %H:%M>"))
     (setq org-time-stamp-custom-formats '("%e %b %Y" . "<%a %b %e %Y %H:%M>"))
     (setq org-confirm-babel-evaluate nil)
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((org . t)
	(latex . t)
	(emacs-lisp . t)
	(sql . t)
	(shell . t)
	(python . t)))
     (general-define-key
      :states '(normal)
      :keymaps 'org-mode-map
      :prefix ","
      (kbd ",") 'org-export-dispatch
      (kbd "t") 'org-time-stamp
      (kbd "s") 'org-babel-execute-src-block
      (kbd "e") 'org-babel-execute-buffer
      (kbd "'") 'org-edit-special)
     (use-package ox-pandoc)
     (use-package htmlize)
   #+END_SRC
** KDE Connect
   Simply KDE connet intergration for emacs
   #+BEGIN_SRC emacs-lisp
     (use-package kdeconnect)
   #+END_SRC
** Nix OS
   Some things for nixos but might get rid of it in the future in
   favor of helm-system-package?
   #+BEGIN_SRC emacs-lisp :noexport
     (use-package nix-mode)
     (use-package helm-nixos-options)
     (general-define-key
      :states '(normal)
      :keymaps 'nix-mode-map
      :prefix "," 
      (kbd "s") 'helm-nixos-options)
     ;; (general-define-key
     ;;       :states '(normal)
     ;;       :keymaps 'nix-mode-map
     ;;       (kbd "S-TAB") 'company-indent-or-complete-common)

   #+END_SRC
** Libvterm
   Terminal emulator based off of a real thing stollen from the neovim
   project. its supposed to actually work.
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat HOME "/Projects/emacs-libvterm"))
     (let (vterm-install)
       (require 'vterm))
     (setq vterm-shell "ion")
   #+END_SRC
** Clipboard Manager
   System clipboard manager
   #+BEGIN_SRC emacs-lisp
     (use-package clipmon)
     (add-to-list 'after-init-hook 'clipmon-mode-start)
     (add-to-list 'after-init-hook 'clipmon-persist)
   #+END_SRC
** System Package Management
   This let me use emerge,apt,dnf,homebrew,macports,guixSD and
   possibly more with helm
   #+BEGIN_SRC emacs-lisp
     (use-package helm-system-packages)
   #+END_SRC
* Post Config
** Backups
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . "~/.saves"))
	   backup-by-copying t
	   delete-old-versions t
	   kept-new-versions 6
	   kept-old-versions 2
	   version-control t)
   #+END_SRC
** Misc
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-screen t)
     (setq initial-buffer-choice 'eshell)
     ;; Theme stuff for emacs --daemon idk why it works  @TODO(renzix): Make this work
     (defvar my:theme 'apropospriate-dark)
     (defvar my:theme-window-loaded nil)
     (defvar my:theme-terminal-loaded nil)

     (if (daemonp)
	 (add-hook 'after-make-frame-functions(lambda (frame)
						(select-frame frame)
						(if (window-system frame)
						    (unless my:theme-window-loaded
						      (if my:theme-terminal-loaded
							  (enable-theme my:theme)
							(load-theme my:theme t))
						      (setq my:theme-window-loaded t))
						  (unless my:theme-terminal-loaded
						    (if my:theme-window-loaded
							(enable-theme my:theme)
						      (load-theme my:theme t))
						    (setq my:theme-terminal-loaded t)))))

       (progn
	 (load-theme my:theme t)
	 (if (display-graphic-p)
	     (setq my:theme-window-loaded t)
	   (setq my:theme-terminal-loaded t))))
     (setq org-src-tab-acts-natively t)

     ;;On save it adds buffer to bookmarks. LastSave is every time and get overridden while projectile is only 
     ;;if in a projectile dir. the last one is every file that is saved gets added.
     (add-hook 'after-save-hook '(lambda () (bookmark-set "LastSave" nil)))
     (add-hook 'after-save-hook '(lambda () (if (projectile-file-exists-p (buffer-name)) (bookmark-set (concat "LastPro" (projectile-project-name)) nil))))
     (add-hook 'after-save-hook '(lambda () (bookmark-set (buffer-name) nil)))

   #+END_SRC
   
   
